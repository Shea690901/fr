/*** Sex Change Spell ***/
/*** By Wonderflug ***/

#define SP_NAME "Sex Change"
#define SPHERE "Quest"
#define LEVELX 7
#define GP_COST 200
#define TYPE "laughter"

inherit "/std/spells/patch.c";

/* help function */
string help() 
{
  return "\n\n"
    "Spell Name: " SP_NAME "\n"
    "Sphere: " SPHERE "\n"
    "Level: "+LEVELX+"\n"
    "Gp Cost: "+GP_COST+"\n"
    "Description: \n"
    "  This powerful enchantment calls upon the power "
    "of your diety to change the sex of a target.  "
    "Due to its nature, its very taxing on the caster, "
    "and even the highest priests must meditate for days "
    "to cast it.  "
    "No guarantee is made that the sexual urges of the "
     "target will change too, of course.\n\n";
}

/* Prototype */
mixed spell(string str, object caster, int cast);

/* If this is cast by an NPC, cast will be the NPC casting it.  Otherwise
 * it will be 0.
 * str is the argument string, ie, targets as typed by the player.
 */
int cast_spell(string str, object cast)
{
  mixed ret;
  object caster;

  if(cast) 
    caster = cast;
  else 
  {
    /* The caster is a player, and the target string may contain nicknames
     * which need expansion to their definitions prior to using them.
     */
    caster = this_player();
    str = caster->expand_nickname(str);
  }

  /* Cast the spell.  Will return a string if there's an error; otherwise
   * assume success.  Note we call with a 1 to indicate the spell is being
   * cast.  This way creators can do the same call with a 0 and have the
   * messages/gp requirements suppressed.
   */
  ret = spell(str, caster, 1);
  if (stringp(ret))
  {
	 notify_fail(ret);
	 return 0;
  }

  tell_object(caster,"You start to cast " SP_NAME ".\n");
  tell_room(environment(caster),caster->query_cap_name()+" begins to cast "
	"a spell.\n", caster);
  return 1;
}

/* This is just for convenience.  Checks that should be done each
 * round of casting/in multiple places should go in this function.
 */
mixed do_checks(string str, object caster, int cast)
{
  object* ob;
  /* Find the targets.  Note that this should be repeated on each stage
   * of the spell, if the effects are not instantaneous.  Some of course
   * may only need to check targets at the end. (eg a spell hitting everything
   * in the room)  At any rate, delete one of these before use :)
   */

  /* This is the first way.  A single target. */
  ob = find_one_match(str, environment(caster));
  if (sizeof(ob))
    ob = ob[0];
  else
    return "You don't see your target here.\n";

  if ( !ob->query_alive() || !living(ob) )
    return "Sex is irrelevant to that.\n";
  return ob;
}

mixed spell(string str, object caster, int cast)
{
  mixed ob;

  /* Can only cast one spell from a given sphere/school at a time */
  if ((int)caster->query_spell_effect(SPHERE))
    return "You are already casting a " SPHERE " spell.\n";
  
  /* Do error checks; if we don't get a string we get the objects */
  if ( stringp( ob=do_checks(str, caster, cast) ) )
    return ob;

  /* Do the spell effects here and delete the following lines, or add
   * a casting delay and modify the following lines.  
   */
  caster->add_spell_effect(3, SPHERE, SP_NAME,
    this_object(), "hb_spell", ({ str, cast, ob }));
  return 1;
}

/* If using add_spell_effect, this function will get called each round
 * for the number of rounds you specified.  caster is the object casting the
 * spell; params is that last parameter you passed to add_spell_effect
 * exactly how you passed it, and time is the number of rounds remaining
 * in the effect.  eg, if we specified 3 in add_spell_effect, this would
 * get called successively with 3, 2, and 1 as the third parameter.
 * NOTE: Always return low numbers (preferably zero) from these spell
 * heartbeats-- the return value gets added to the player as xp.
 */
int hb_spell(object caster, mixed *params, int time)
{
  mixed ob;
  int cost;

  /* Add/delete from this as necessary. Note we only do tell_room's if 
   * the spell was cast, ie, params[1] is nonzero 
   */
  switch( time )
  {
    case 3:
      if ( stringp( ob=do_checks(params[0], caster, params[1]) ) )
      {
        tell_object(caster, ob);
        if ( params[1] )
          tell_room(environment(caster), caster->query_cap_name()+" stops casting.\n",
            caster);
        call_out("end_spell", 0, caster);
        return 0;
      }
      tell_object(caster, "A nimbus of power forms in front of you.\n");
      tell_room(environment(caster), "A nimbus of power forms in front of "+
        caster->query_cap_name()+".\n", caster);
      return 0;

    case 2:
      if ( stringp( ob=do_checks(params[0], caster, params[1]) ) )
      {
        tell_object(caster, ob);
        if ( params[1] )
          tell_room(environment(caster), caster->query_cap_name()+" stops casting.\n",
            caster);
        call_out("end_spell", 0, caster);
        return 1;
      }
      if ( ob->query_gender() == 1 )
      {
        tell_object(caster, "You shape the nimbus of power into a "
          "huge, glimmering pair of gardening shears.\n");
        tell_room(environment(caster), caster->query_cap_name()+" gestures, and the "
          "nimbus of power molds into a pair of...\n"
          "gardening shears?\n", caster);
      }
      else
      {
        tell_object(caster, "You form the nimbus of power into something "
        "rather phallic, and best not described here.\n");
        tell_room(environment(caster), caster->query_cap_name()+
          " shapes the nimbus of power into something "
          "indescribably phallic.\n", caster);
      }
      return 0;

    default:
      break;
  }
  if ( stringp( ob=do_checks(params[0], caster, params[1]) ) )
  {
    tell_object(caster, ob);
    tell_room(environment(caster), caster->query_cap_name()+" stops casting.\n",
      caster);
    return 0;
  }

  cost = GP_COST;
   if( params[1] && caster->query_gp() > cost )
  {
      caster->adjust_gp(-cost);
    tell_object(caster, "You are too exhausted to complete the spell.\n");
    tell_room(environment(caster), caster->query_cap_name()+
      " stops casting.\n", caster);
  }



  ob->set_gender( (ob->query_gender()==1?2:1) );
  if ( ob->query_gender() == 1 )
  {
    tell_object(caster, "You send the.. nimbus.. hurling at "+
      ob->query_cap_name()+".\nThere's a large flash, a scream, and "
      "suddenly "+ob->query_cap_name()+" is a new man.\n");
    tell_object(ob, "The phallic nimbus suddenly hurtles toward you, "
      "and you scream as a very fundamental change comes over you.\n");
    tell_room(environment(caster), caster->query_cap_name()+
      " gestures, and the phallic nimbus hurtles toward "+
      ob->query_cap_name()+".\nA flash of light, and a scream, and "
      "you notice some change in "+ob->query_cap_name()+".\n",
      ({ ob, caster }) );
  }
  else
  {
    tell_object(ob, "The glowing shears of power hurtle at you, "
    "ripping through your armor and suddenly exploding.\n"
    "You feel something missing...\n");
  tell_object(caster, "You send the glowing shears of power "
    "at "+ob->query_cap_name()+", who screams and suddenly looks "
    "\nto have lost something vital.\n");
  tell_room(environment(caster), caster->query_cap_name()+" gestures, "
    "and the shears of power hurtle at "+ob->query_cap_name()+
    ", who is enveloped screaming in bright light.\n"
    "When the light fades, "+ob->query_cap_name()+" appears to have lost something vital.\n",
    ({ ob, caster }) );
  }

  return 0;
}


void end_spell(object ob)
{
  ob->remove_spell_effect(SP_NAME);
  return;
}
