*****

This file has been roughly organized in the following order:

    1) non-fatal
    2) memory leaks
    3) fatal or potentially fatal

*****

            Problems with nomask inheritance in MudOS:

Problem analysis by Luke Mewburn <zak@rmit.oz.au>, coding as Zak@Ivory.Tower

There seem to be some inconsistancies in the way that MudOS inheritance
works with the `nomask' pre-function operator. For purposes of example,
I'll show the following inheritance tree that I used whilst testing:

                                gp
                                |
                                |
                                par
                        /               \
                   /                         \
                bro                             sis
                 |
                 |
                bson
        nomask mixed query(string x)

In all the tests, there was a function `query' in bson which was nomasked
at all times (unless a specific test mentions its removal for that test
only)

Problems:
- unable, without a prototype, to call query() in sis. Got (for obvious
  reasons)  `Undefined function query'.

- In sis, a prototype of the form 'mixed query(string x);' allows sis to
  to compile, and is ok when par is compiled, but when when attempting to
  compile/load gp get the error 'Illegal to redefine nomasked function'.
  So, it seems that the way prototypes are handled when merging in
  function tables from bro and sis into par, then into gp, is having
  problems in the last stage checks.

- attempting to resolve this, I tried in sis something like:
    `private mixed query(string x) { return this_object()->query(x); }'
  Again, the illegal nomask error for gp. Now, of all the problems, THIS
  one stumps me. According to what I read, defining it as private should
  mean that it won't get propagated back in the inheritance tree (from sis
  -> par -> gp), and thus, shouldn't interfere with the nomask in bson.
  Maybe I misunderstand private...

- the above was tried with `private static' instead of private...

- removing the nomask from query in bson allows gp to compile, but defeats
  the purpose of why we nomasked in the first place...

- the solution of replacing all query()'s in sis with `this_object()->query()'
  works, but this is inelegant.

So, whilst we have a working idea with the this_object()->query stuff, why
did the compiler choke on a private function in a different branch of
inheritance apparantly masking a nomask func (when my idea of private is that
it doesn't work that way.) I suspect that checking isn't correctly done in
the compiler.y function that merges in inherited function tables...

Any ideas??

Comment:
    This problem spotted by Telsin@ivory.tower (budic@marvin.macc.wisc.edu),
    and apparently also experienced by Watcher@tmi-2 while recoding their new
    player object. Watcher got around it with this_object()->query() calls.
    Ivory Tower is running under A/UX 3.0, currently on a Mac IIci w/ 20 megs
    RAM.  Current driver version is 0.9.17.5, but the problem was first noted
    in 0.9.16.21 or so.  [Truilkan tried Lars 3.1.2 and found the same problem].

-----

heart_beat() is not shadowable

-----

function f;

f = (: this_object(), ({"func", "arg1"}) :);

functionp(f) doesn't return 1

-john

Comment:
    This is a documented feature of functionp()--it returns 2 to identify
    the array.

-----

I think if you do something like:

  f = (: ob, ({ func, a, b, c }) :);
  ...
  (*f)(d, e, f);

then the order of arguments may not be what the programmer expects...
(it will be like func(d,e,f,a,b,c))

(djohnson@cs.ucsd.edu)

-----

need a way to tell the driver to try reconnecting to the addr_server
after it has gone down and come back up (the addr_server).  maybe
the driver could just retry every now and then?

--john

-----

During the create() of a virtual object, file_name() returns the wrong name.

(source unknown)

Comment:
This is not a bug, it's due to a misunderstanding of how virtual objects
work.  The object returned by master::compile_object() is 'transformed'
to have the requested file name.  How the master object comes up with
the object in question is entirely arbitrary, and it need not even be a
new clone, so create() isn't necessarily called.  It is possible, for
example to return an existing object, and the object would then have
it's filename changed.

-----

The Solaris compiler doesn't define SunOS_5 (only gcc for Solaris does), so
if gcc isn't being used, SunOS_5 needs to be #define'd manually?

(source unknown)

-----

In move_or_destruct() of simulate.c [line 1966 in 0.9.18.31, I believe.]
there is an apply to the move() of the dested object.  This hidden little
bit of behavior was causing us a bit of a problem since our move lfun
was move(dest, force-the-move).  forcing the move was always true of course,
so players autoloads were not dested, they were moved to the env of the
player.

I don't know whether the above code is a bug, or just an undocumented
feature.  Perhaps it should be a master apply.  I do know that the lack
of documentation of it made for a sticky debugging problem in the mudlib
after we added the force-the-move flag to move().

Thank you for you attention, and for all your work on the driver.

Erik B. Flom
Artagel

Comment:
    This is an undocumented feature of destruct().  The 1 flag to move()
    tells the object to move or get destruct()'d.

    But as JnA puts it;
      `` This is very dubious, why not just destruct them? ''

-----

Note  19  Schoenf      (Wed Sep  8)  patch_in(), patch_out() for 64-Bit machines

I'm running MUDOS on a alpha and I like to fix this thing with patch
in and patch_out .....

can one give me directions ??

-schoenf

Comment:
    Hmm, I could whip something up for an alpha I suppose
    (or something assumed to work on an alpha, since I can
    only use them when a certain prof isn't in town).
    However, the same problems in the patch_in and patch_out
    *also* occur in the parser when processing switch statements,
    and in the f_switch efun.  That is, it assumes keys are
    4 bytes long.  I suspect that if this actually works at
    the moment on an alpha, it's because the upper 32 bits
    in these addresses are all 0's or something similar.

    So if patch_in/patch_out get fixed, the switch code will also
    need fixing at the same time.

    (djohnson@cs.ucsd.edu)

-----

read_file() doesn't guarantee that a "/" is at the start of the filename
before passing to valid_read()...same problem might exist with
write_file(), read_bytes(), write_bytes(), didn't check yet

(ucs_brf@pip.shsu.edu)

Comment: This problem is rather common in the driver currently.  Internally,
filenames have no leading '/'.  One should probably be added every time
a filename is passed to the mudlib.

-----

The following program,

...
// crash.c
move(dst) { move_object(dst);        }
init()    { destruct(this_player()); }
...

crashes the driver when you do:
  new("/whereever/crash")->move(this_player());

bobf

-----

hm, Linux apparently doesn't let you open a directory for reading. boggle.
so all the efuns that read from a file will screw up if you try
to use a dir as the file.  ack

ucs_brf@pip.shsu.edu

-----

I'm told that the size limit for add_message() isn't being checked in
tell_object(), so one too large will crash....

ucs_brf@pip.shsu.edu

-----

sprintf() crasher

    eval return sprintf("%'0'2d", "3");

    ERROR: (s)printf(): Incorrect argument type to %d. (arg: 0)
    stralloc.c: free_string called on non-shared string: %'0.

Publius@TMI-2

Comment:
    sprintf.c should probably be rewritten as it has a nasty habit of
    munging the stack and writing to places without checking the destination
    type if it's ok; probably should also remove need for setjmp/longjmp;
    also: err = setjmp(...) is non strict ANSI portable according to SAS
    tech support for their C compiler (SAS/C)

-----

    mixed a;
    do {} while (a = ({ a, "" }));

Profezzorn@TMI-2

Comment:
    It would be nice if things like this, where all the memory (VM too)
    is sucked up by a runaway program, didn't cause the driver to
    shutdown ("Out of memory").

-----

The grammar doesn't fully distinguish between lvalues and non-lvalues.
For example, this is a crasher:

return ((mapping)find_object("/d/TMI/mudosrm")->query("exits")
	["south"] = "/d/TMI/driverrm";

Note the '=' rather than '=='.

Comment:
    Fixing this means (major?) changes to compiler.y ... it's part of
    the reason why range lvalues don't work; it's also related to lvalue
    backpatching in expr4.

Comment#2: lpc_compiler.y suffers from a similar, though unrelated problem.
    lvalues are handled quite differently by the compiler, eliminating the
    need for backpatching, so the above crasher doesn't crash in LPC->C;
    it instead actually CHANGES the exit.  Whether this is a "bug" or a
    "feature" is debatable :)
